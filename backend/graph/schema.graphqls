# GraphQL schema for DeGov Apps
#
# https://gqlgen.com/getting-started/

scalar Time

### ==== directives

# Authentication directive
directive @auth(required: Boolean = true) on FIELD_DEFINITION

# Authorization directive for resource ownership
directive @authorize(rule: AuthRule!) on FIELD_DEFINITION

enum AuthRule {
  OWNER_ONLY # User can only access their own resources
  ADMIN_ONLY # Admin only access
  PUBLIC # Public access (no auth required)
}

enum ConfigFormat {
  YAML
  JSON
}

enum LikeAction {
  LIKE
  UNLIKE
}

enum ProposalState {
  PENDING
  ACTIVE
  CANCELED
  DEFEATED
  SUCCEEDED
  QUEUED
  EXECUTED
  EXPIRED
}

### ==== entities

type User {
  id: ID!
  address: String!
  email: String
  # likedDaos: [UserLikedDao!]!
  # followedDaos: [UserFollowedDao!]!
  # channels: [UserChannel!]!
  # notificationRecords: [NotificationRecord!]!
  ctime: Time!
  utime: Time
}

type Dao {
  id: ID!
  chainId: Int!
  chainName: String!
  chainLogo: String
  name: String!
  code: String!
  logo: String
  seq: Int!
  endpoint: String! # Website endpoint
  state: String!
  tags: [String!]
  timeSyncd: Time
  metricsCountProposals: Int!
  metricsCountMembers: Int!
  metricsSumPower: String!
  metricsCountVote: Int!
  lastTrackingBlock: Int!
  ctime: Time!
  utime: Time
  # liked: Boolean
  # subscribed: Boolean
  chips: [DaoChip!]
  lastProposal: Proposal
}

type DaoChip {
  id: ID!
  daoCode: String!
  chipCode: String!
  flag: String!
  additional: String
  ctime: Time!
  utime: Time
}

type Proposal {
  id: ID!
  daoCode: String!
  chainId: Int!
  proposalLink: String!
  proposalId: String!
  state: ProposalState!
  proposalAtBlock: Int!
  proposalCreatedAt: Time!
  timesTrack: Int!
  timeNextTrack: Time
  message: String
  ctime: Time!
  utime: Time
}

# type UserLikedDao {
#   id: ID!
#   daoCode: String!
#   userId: String!
#   ctime: Time!
#   user: User!
#   dao: Dao!
# }

# type UserFollowedDao {
#   id: ID!
#   chainId: Int!
#   daoCode: String!
#   userId: String!
#   enableNewProposal: Int!
#   enableVotingEndReminder: Int!
#   ctime: Time!
#   user: User!
#   dao: Dao!
# }

# type NotificationRecord {
#   id: ID!
#   chainId: Int!
#   chainName: String!
#   daoName: String!
#   daoCode: String!
#   type: NotificationType!
#   targetId: String
#   userId: String!
#   status: NotificationStatus!
#   message: String
#   retryTimes: Int!
#   ctime: Time!
#   user: User!
# }

# type UserChannel {
#   id: ID!
#   userId: String!
#   verified: Int!
#   channelType: ChannelType!
#   channelValue: String!
#   payload: String
#   ctime: Time!
#   user: User!
# }

### === outputs

type GetNonceOutput {
  nonce: String!
}

type LoginOutput {
  token: String!
}

### === enums

# enum NotificationType {
#   NEW_PROPOSAL
#   VOTE
#   STATUS
#   VOTE_END_REMINDER
# }

# enum NotificationStatus {
#   SENT_OK
#   SENT_FAIL
# }

# enum ChannelType {
#   EMAIL
#   SMS
#   PUSH
# }

### === inputs

input GetNonceInput {
  length: Int
}

input LoginInput {
  message: String!
  signature: String!
}

input GetDaoConfigInput {
  daoCode: String!
  format: ConfigFormat
}

# input CreateUserInput {
#   address: String!
#   email: String
# }

# input UpdateUserInput {
#   email: String
# }

# input CreateDaoInput {
#   chainId: Int!
#   name: String!
#   code: String!
#   configLink: String!
# }

input ModifyLikeDaoInput {
  daoCode: String!
  action: LikeAction!
}

# input FollowDaoInput {
#   chainId: Int!
#   daoCode: String!
#   userId: String!
#   enableNewProposal: Int!
#   enableVotingEndReminder: Int!
# }

### ==== graphql

type Query {
  # Auth queries (no authentication required)
  nonce(input: GetNonceInput!): String!

  # DAO queries (no authentication required, but auth info affects result)
  daos: [Dao!]! @auth(required: false)
  likedDaos: [Dao!]! @auth(required: false)
  subscribedDaos: [Dao!]! @auth(required: false)
  daoConfig(input: GetDaoConfigInput): String!

  # dao(id: ID!): Dao @auth(required: false)
  # daoByCode(code: String!): Dao @auth(required: false)

  # # User queries (require authentication for some)
  # users: [User!]! @auth @authorize(rule: ADMIN_ONLY)
  # user(id: ID!): User @auth(required: false)
  # userByAddress(address: String!): User @auth(required: false)
  # me: User! @auth @authorize(rule: OWNER_ONLY)

  # # User interactions (require authentication)
  # userLikedDaos(userId: String!): [UserLikedDao!]! @auth @authorize(rule: OWNER_ONLY)
  # userFollowedDaos(userId: String!): [UserFollowedDao!]! @auth @authorize(rule: OWNER_ONLY)
}

type Mutation {
  # Auth mutations
  login(input: LoginInput!): LoginOutput!

  # User interactions
  modifyLikeDao(input: ModifyLikeDaoInput!): Boolean! @auth
  # followDao(input: FollowDaoInput!): UserFollowedDao! @auth @authorize(rule: OWNER_ONLY)
  # unfollowDao(userId: String!, daoCode: String!): Boolean! @auth @authorize(rule: OWNER_ONLY)
}

# type Subscription {
#   # notificationCreated(userId: String!): NotificationRecord!
#   # daoUpdated(daoCode: String!): Dao!
# }
