package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"fmt"
	"time"

	"github.com/jinzhu/copier"
	dbmodels "github.com/ringecosystem/degov-square/database/models"
	gqlmodels "github.com/ringecosystem/degov-square/graph/models"
	"github.com/ringecosystem/degov-square/internal"
	"github.com/ringecosystem/degov-square/services"
	"github.com/ringecosystem/degov-square/types"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input gqlmodels.LoginInput) (*gqlmodels.LoginOutput, error) {
	output, err := r.authService.Login(input)
	if err != nil {
		return nil, fmt.Errorf("login failed: %v", err)
	}

	return &output, nil
}

// ModifyLikeDao is the resolver for the modifyLikeDao field.
func (r *mutationResolver) ModifyLikeDao(ctx context.Context, input gqlmodels.ModifyLikeDaoInput) (bool, error) {
	user, _ := r.authUtils.GetUser(ctx)
	result, err := r.userInteractionService.ModifyLikeDao(types.BasicInput[gqlmodels.ModifyLikeDaoInput]{
		User:  user,
		Input: input,
	})
	return result, err
}

// VerifyNotificationChannel is the resolver for the verifyNotificationChannel field.
func (r *mutationResolver) VerifyNotificationChannel(ctx context.Context, input gqlmodels.VerifyNotificationChannelInput) (*gqlmodels.VerifyNotificationChannelOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.userInteractionService.VerifyNotificationChannel(types.BasicInput[gqlmodels.VerifyNotificationChannelInput]{
		User:  user,
		Input: input,
	})
}

// ResendOtp is the resolver for the resendOTP field.
func (r *mutationResolver) ResendOtp(ctx context.Context, input gqlmodels.BaseNotificationChannelInput) (*gqlmodels.ResendOTPOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.userInteractionService.ResendOTP(types.BasicInput[gqlmodels.BaseNotificationChannelInput]{
		User:  user,
		Input: input,
	})
}

// SubscribeDao is the resolver for the subscribeDao field.
func (r *mutationResolver) SubscribeDao(ctx context.Context, input gqlmodels.SubscribeDaoInput) (*gqlmodels.SubscribedDaoOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	result, err := r.subscribeService.SubscribeDao(types.BasicInput[gqlmodels.SubscribeDaoInput]{
		User:  user,
		Input: input,
	})
	return result, err
}

// SubscribeProposal is the resolver for the subscribeProposal field.
func (r *mutationResolver) SubscribeProposal(ctx context.Context, input gqlmodels.SubscribeProposalInput) (*gqlmodels.SubscribedProposalOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	result, err := r.subscribeService.SubscribeProposal(types.BasicInput[gqlmodels.SubscribeProposalInput]{
		User:  user,
		Input: input,
	})
	return result, err
}

// UnsubscribeDao is the resolver for the unsubscribeDao field.
func (r *mutationResolver) UnsubscribeDao(ctx context.Context, input gqlmodels.UnsubscribeDaoInput) (*gqlmodels.SubscribedDaoOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.subscribeService.UnsubscribeDao(types.BasicInput[gqlmodels.UnsubscribeDaoInput]{
		User:  user,
		Input: input,
	})
}

// UnsubscribeProposal is the resolver for the unsubscribeProposal field.
func (r *mutationResolver) UnsubscribeProposal(ctx context.Context, input gqlmodels.UnsubscribeProposalInput) (*gqlmodels.SubscribedProposalOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.subscribeService.UnsubscribeProposal(types.BasicInput[gqlmodels.UnsubscribeProposalInput]{
		User:  user,
		Input: input,
	})
}

// Nonce is the resolver for the nonce field.
func (r *queryResolver) Nonce(ctx context.Context, input gqlmodels.GetNonceInput) (string, error) {
	nonce, err := r.authService.Nonce(input)
	if err != nil {
		return "", err
	}
	if nonce == "" {
		return "", fmt.Errorf("failed to generate nonce")
	}
	return nonce, nil
}

// Daos is the resolver for the daos field.
func (r *queryResolver) Daos(ctx context.Context) ([]*gqlmodels.Dao, error) {
	user, _ := r.authUtils.GetUser(ctx)

	// User is authenticated, return DAOs with personalized info (liked, subscribed, etc.)
	// For now, just call the regular method - you can extend this later
	return r.daoService.ListDaos(types.BasicInput[*types.ListDaosInput]{
		User: user,
		Input: &types.ListDaosInput{
			State: &[]dbmodels.DaoState{dbmodels.DaoStateActive},
		},
	})
}

// LikedDaos is the resolver for the likedDaos field.
func (r *queryResolver) LikedDaos(ctx context.Context) ([]*gqlmodels.Dao, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.userLikedService.LikedDaos(types.BasicInput[*string]{
		User:  user,
		Input: nil,
	})
}

// DaoConfig is the resolver for the daoConfig field.
func (r *queryResolver) DaoConfig(ctx context.Context, input *gqlmodels.GetDaoConfigInput) (string, error) {
	return r.daoConfigService.RawConfig(gqlmodels.GetDaoConfigInput{
		DaoCode: input.DaoCode,
		Format:  input.Format,
	})
}

// EvmAbi is the resolver for the evmAbi field.
func (r *queryResolver) EvmAbi(ctx context.Context, input gqlmodels.EvmAbiInput) ([]*gqlmodels.EvmAbiOutput, error) {
	// panic(fmt.Errorf("not implemented: EvmAbi - evmAbi"))
	return r.evmChainService.GetAbi(input)
}

// ListNotificationChannels is the resolver for the listNotificationChannels field.
func (r *queryResolver) ListNotificationChannels(ctx context.Context) ([]*gqlmodels.NotificationChannel, error) {
	user, _ := r.authUtils.GetUser(ctx)
	channels, err := r.userInteractionService.ListChannel(types.BasicInput[types.ListChannelInput]{
		User:  user,
		Input: types.ListChannelInput{},
	})
	if err != nil {
		return nil, err
	}
	var result []*gqlmodels.NotificationChannel
	copier.Copy(&result, &channels)
	return result, nil
}

// SubscribedDaos is the resolver for the subscribedDaos field.
func (r *queryResolver) SubscribedDaos(ctx context.Context) ([]*gqlmodels.SubscribedDao, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.userSubscribedService.SubscribedDaos(types.BasicInput[*string]{
		User:  user,
		Input: nil,
	})
}

// SubscribedProposals is the resolver for the subscribedProposals field.
func (r *queryResolver) SubscribedProposals(ctx context.Context) ([]*gqlmodels.SubscribedProposal, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.userSubscribedService.SubscribedProposals(types.BasicInput[*string]{
		User:  user,
		Input: nil,
	})
}

// SummaryProposalStates is the resolver for the summaryProposalStates field.
func (r *queryResolver) SummaryProposalStates(ctx context.Context, input gqlmodels.SummaryProposalStatesInput) ([]*gqlmodels.SummaryProposalStates, error) {
	return r.proposalService.SummaryProposalStates(input)
}

// TreasuryAssets is the resolver for the treasuryAssets field.
func (r *queryResolver) TreasuryAssets(ctx context.Context, input *gqlmodels.TreasuryAssetsInput) ([]*gqlmodels.TreasuryAsset, error) {
	return r.treasuryService.LoadTreasuryAssets(input)
}

// VoteTracking is the resolver for the voteTracking field.
func (r *queryResolver) VoteTracking(ctx context.Context, input gqlmodels.VoteTrackingInput) (*gqlmodels.VoteTracking, error) {
	// Convert types for service call
	chainID := int(input.ChainID)
	var fulfilledFilter *int
	if input.Fulfilled != nil {
		f := int(*input.Fulfilled)
		fulfilledFilter = &f
	}

	// Find proposal by chain and proposal ID
	proposal, err := r.proposalService.FindByChainAndProposalID(chainID, input.ProposalID, fulfilledFilter)
	if err != nil || proposal == nil {
		return nil, nil // Return nil instead of error for not found
	}

	// Get DAO info
	dao, _ := r.daoService.GetByCode(proposal.DaoCode)

	// Build response
	var utime *time.Time
	if proposal.UTime != nil {
		utime = proposal.UTime
	}

	result := &gqlmodels.VoteTracking{
		ID:               proposal.ID,
		DaoCode:          proposal.DaoCode,
		ProposalID:       proposal.ProposalID,
		ChainID:          int32(proposal.ChainId),
		State:            string(proposal.State),
		Errored:          int32(proposal.FulfillErrored),
		Fulfilled:        int32(proposal.Fulfilled),
		FulfilledExplain: proposal.FulfilledExplain,
		Ctime:            proposal.CTime,
		Utime:            utime,
	}

	if dao != nil {
		result.Dao = &gqlmodels.VoteTrackingDao{
			ID:   dao.ID,
			Code: dao.Code,
			Name: dao.Name,
			Logo: dao.Logo,
		}
	}

	return result, nil
}

// BotAddress is the resolver for the botAddress field.
func (r *queryResolver) BotAddress(ctx context.Context) (string, error) {
	return internal.GetAgentAddress(), nil
}

// ProposalSummary is the resolver for the proposalSummary field.
func (r *queryResolver) ProposalSummary(ctx context.Context, input gqlmodels.ProposalSummaryInput) (string, error) {
	return r.proposalSummaryService.GetOrGenerateSummary(services.ProposalSummaryInput{
		ProposalID: input.ProposalID,
		ChainID:    int(input.ChainID),
		Indexer:    input.Indexer,
	})
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
