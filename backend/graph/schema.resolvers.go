package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	"github.com/jinzhu/copier"
	dbmodels "github.com/ringecosystem/degov-square/database/models"
	gqlmodels "github.com/ringecosystem/degov-square/graph/models"
	"github.com/ringecosystem/degov-square/types"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input gqlmodels.LoginInput) (*gqlmodels.LoginOutput, error) {
	output, err := r.authService.Login(input)
	if err != nil {
		return nil, fmt.Errorf("login failed: %v", err)
	}

	return &output, nil
}

// ModifyLikeDao is the resolver for the modifyLikeDao field.
func (r *mutationResolver) ModifyLikeDao(ctx context.Context, input gqlmodels.ModifyLikeDaoInput) (bool, error) {
	user, _ := r.authUtils.GetUser(ctx)
	result, err := r.userInteractionService.ModifyLikeDao(types.BasicInput[gqlmodels.ModifyLikeDaoInput]{
		User:  user,
		Input: input,
	})
	return result, err
}

// VerifyNotificationChannel is the resolver for the verifyNotificationChannel field.
func (r *mutationResolver) VerifyNotificationChannel(ctx context.Context, input gqlmodels.VerifyNotificationChannelInput) (*gqlmodels.VerifyNotificationChannelOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.userInteractionService.VerifyNotificationChannel(types.BasicInput[gqlmodels.VerifyNotificationChannelInput]{
		User:  user,
		Input: input,
	})
}

// ResendOtp is the resolver for the resendOTP field.
func (r *mutationResolver) ResendOtp(ctx context.Context, input gqlmodels.BaseNotificationChannelInput) (*gqlmodels.ResendOTPOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.userInteractionService.ResendOTP(types.BasicInput[gqlmodels.BaseNotificationChannelInput]{
		User:  user,
		Input: input,
	})
}

// SubscribeDao is the resolver for the subscribeDao field.
func (r *mutationResolver) SubscribeDao(ctx context.Context, input gqlmodels.SubscribeDaoInput) (*gqlmodels.SubscribedDaoOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	result, err := r.subscribeService.SubscribeDao(types.BasicInput[gqlmodels.SubscribeDaoInput]{
		User:  user,
		Input: input,
	})
	return result, err
}

// SubscribeProposal is the resolver for the subscribeProposal field.
func (r *mutationResolver) SubscribeProposal(ctx context.Context, input gqlmodels.SubscribeProposalInput) (*gqlmodels.SubscribedProposalOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	result, err := r.subscribeService.SubscribeProposal(types.BasicInput[gqlmodels.SubscribeProposalInput]{
		User:  user,
		Input: input,
	})
	return result, err
}

// UnsubscribeDao is the resolver for the unsubscribeDao field.
func (r *mutationResolver) UnsubscribeDao(ctx context.Context, input gqlmodels.UnsubscribeDaoInput) (*gqlmodels.SubscribedDaoOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.subscribeService.UnsubscribeDao(types.BasicInput[gqlmodels.UnsubscribeDaoInput]{
		User:  user,
		Input: input,
	})
}

// UnsubscribeProposal is the resolver for the unsubscribeProposal field.
func (r *mutationResolver) UnsubscribeProposal(ctx context.Context, input gqlmodels.UnsubscribeProposalInput) (*gqlmodels.SubscribedProposalOutput, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.subscribeService.UnsubscribeProposal(types.BasicInput[gqlmodels.UnsubscribeProposalInput]{
		User:  user,
		Input: input,
	})
}

// Nonce is the resolver for the nonce field.
func (r *queryResolver) Nonce(ctx context.Context, input gqlmodels.GetNonceInput) (string, error) {
	nonce, err := r.authService.Nonce(input)
	if err != nil {
		return "", err
	}
	if nonce == "" {
		return "", fmt.Errorf("failed to generate nonce")
	}
	return nonce, nil
}

// Daos is the resolver for the daos field.
func (r *queryResolver) Daos(ctx context.Context) ([]*gqlmodels.Dao, error) {
	user, _ := r.authUtils.GetUser(ctx)

	// User is authenticated, return DAOs with personalized info (liked, subscribed, etc.)
	// For now, just call the regular method - you can extend this later
	return r.daoService.ListDaos(types.BasicInput[*types.ListDaosInput]{
		User: user,
		Input: &types.ListDaosInput{
			State: &[]dbmodels.DaoState{dbmodels.DaoStateActive},
		},
	})
}

// LikedDaos is the resolver for the likedDaos field.
func (r *queryResolver) LikedDaos(ctx context.Context) ([]*gqlmodels.Dao, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.userLikedService.LikedDaos(types.BasicInput[*string]{
		User:  user,
		Input: nil,
	})
}

// DaoConfig is the resolver for the daoConfig field.
func (r *queryResolver) DaoConfig(ctx context.Context, input *gqlmodels.GetDaoConfigInput) (string, error) {
	return r.daoConfigService.RawConfig(gqlmodels.GetDaoConfigInput{
		DaoCode: input.DaoCode,
		Format:  input.Format,
	})
}

// EvmAbi is the resolver for the evmAbi field.
func (r *queryResolver) EvmAbi(ctx context.Context, input gqlmodels.EvmAbiInput) ([]*gqlmodels.EvmAbiOutput, error) {
	// panic(fmt.Errorf("not implemented: EvmAbi - evmAbi"))
	return r.evmChainService.GetAbi(input)
}

// ListNotificationChannels is the resolver for the listNotificationChannels field.
func (r *queryResolver) ListNotificationChannels(ctx context.Context) ([]*gqlmodels.NotificationChannel, error) {
	user, _ := r.authUtils.GetUser(ctx)
	channels, err := r.userInteractionService.ListChannel(types.BasicInput[types.ListChannelInput]{
		User:  user,
		Input: types.ListChannelInput{},
	})
	if err != nil {
		return nil, err
	}
	var result []*gqlmodels.NotificationChannel
	copier.Copy(&result, &channels)
	return result, nil
}

// SubscribedDaos is the resolver for the subscribedDaos field.
func (r *queryResolver) SubscribedDaos(ctx context.Context) ([]*gqlmodels.SubscribedDao, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.userSubscribedService.SubscribedDaos(types.BasicInput[*string]{
		User:  user,
		Input: nil,
	})
}

// SubscribedProposals is the resolver for the subscribedProposals field.
func (r *queryResolver) SubscribedProposals(ctx context.Context) ([]*gqlmodels.SubscribedProposal, error) {
	user, _ := r.authUtils.GetUser(ctx)
	return r.userSubscribedService.SubscribedProposals(types.BasicInput[*string]{
		User:  user,
		Input: nil,
	})
}

// SummaryProposalStates is the resolver for the summaryProposalStates field.
func (r *queryResolver) SummaryProposalStates(ctx context.Context, input gqlmodels.SummaryProposalStatesInput) ([]*gqlmodels.SummaryProposalStates, error) {
	return r.proposalService.SummaryProposalStates(input)
}

// TreasuryAssets is the resolver for the treasuryAssets field.
func (r *queryResolver) TreasuryAssets(ctx context.Context, input *gqlmodels.TreasuryAssetsInput) ([]*gqlmodels.TreasuryAsset, error) {
	return r.treasuryService.LoadTreasuryAssets(input)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
